{"version":3,"file":"cardano-launcher.cjs.production.min.js","sources":["../src/service.ts","../src/logging.ts","../src/byron.ts","../src/jormungandr.ts","../src/cardanoLauncher.ts","../src/shelley.ts","../src/cli.ts"],"sourcesContent":["/**\n * Functions for starting and stopping an individual backend service.\n *\n * The important function is [[setupService]] which creates a [[Service]].\n *\n * @packageDocumentation\n */\n\nimport { spawn, ChildProcess } from 'child_process';\nimport { EventEmitter } from 'tsee';\nimport _ from 'lodash';\n\nimport { Logger } from './logging';\n\nexport interface ServiceExitStatus {\n  /** Program name. */\n  exe: string;\n  /** Process exit status code, if process exited itself. */\n  code: number | null;\n  /** Signal name, if process was killed. */\n  signal: string | null;\n  /** Error object, if process could not be started, or could not be killed. */\n  err: Error | null;\n}\n\n/**\n * Produce an exit message from an exit status.\n * @param res - exit status of service.\n * @return a human readable exit message.\n */\nexport function serviceExitStatusMessage(res: ServiceExitStatus): string {\n  const reason =\n    typeof res.code === 'number'\n      ? `status ${res.code}`\n      : res.signal\n      ? `signal ${res.signal}`\n      : `error ${res.err}`;\n\n  return `${res.exe} exited with ${reason}`;\n}\n\n/**\n * States for a launched process.  The processes are not guaranteed to\n * use all of these states. For example, a process may go directly\n * from `Started` to `Stopped`.\n */\nexport enum ServiceStatus {\n  /** Initial state. */\n  NotStarted,\n  /** Waiting for [[StartService]] info. */\n  Starting,\n  /** Subprocess has been started and has a PID. */\n  Started,\n  /** Caller has requested to stop the process. Now waiting for it to exit, or for the timeout to elapse. */\n  Stopping,\n  /** Subprocess has exited or been killed. */\n  Stopped,\n}\n\n/**\n * A launched process.\n */\nexport interface Service {\n  /**\n   * @return a promise that will be fulfilled when the process has\n   *   started. The returned PID is not guaranteed to be running. It may\n   *   already have exited.\n   */\n  start(): Promise<Pid>;\n\n  /**\n   * Stops the process.\n   * @param timeoutSeconds - how long to wait for the service to stop itself before killing it.\n   *   If `0`, any running timeout kill be cancelled and the process killed immediately.\n   * @return a promise that will be fulfilled when the process has stopped.\n   */\n  stop(timeoutSeconds?: number): Promise<ServiceExitStatus>;\n\n  /**\n   * Waits for the process to finish somehow -- whether it exits by\n   * itself, or exits due to `stop()` being called.\n   *\n   * @return a promise that will be fulfilled when the process has exited.\n   */\n  waitForExit(): Promise<ServiceExitStatus>;\n\n  /**\n   * @return the status of this process.\n   */\n  getStatus(): ServiceStatus;\n\n  /**\n   * An [[EventEmitter]] that can be used to register handlers when\n   * the process changes status.\n   *\n   * ```typescript\n   * launcher.walletService.events.on('statusChanged', status => { ... });\n   * ```\n   */\n  events: ServiceEvents;\n}\n\n/** Process ID */\nexport type Pid = number;\n\n/**\n * The type of events for [[Service]].\n */\ntype ServiceEvents = EventEmitter<{\n  /**\n   * [[Launcher.walletService.events]] and\n   * [[Launcher.nodeService.events]] will emit this when their\n   * processes start or stop.\n   * @event\n   */\n  statusChanged: (status: ServiceStatus) => void;\n}>;\n\n/**\n * Initialise a [[Service]] which can control the lifetime of a\n * backend process.\n *\n * This does not start the process. Use [[Service.start]] for that.\n *\n * @param cfgPromise - a promise which will return the command to run.\n * @param logger - logging object.\n * @return A handle on the [[Service]].\n */\nexport function setupService(\n  cfgPromise: Promise<StartService>,\n  logger: Logger = console\n): Service {\n  const events = new EventEmitter<{\n    statusChanged: (status: ServiceStatus) => void;\n  }>();\n\n  // What the current state is.\n  let status = ServiceStatus.NotStarted;\n  // Fulfilled promise of service command-line.\n  // This will always be defined if status > Starting.\n  let cfg: StartService;\n  // NodeJS child process object, or null if not running.\n  let proc: ChildProcess | null = null;\n  // How the child process exited, or null if it hasn't yet exited.\n  let exitStatus: ServiceExitStatus | null;\n  // For cancelling the kill timeout.\n  let killTimer: NodeJS.Timeout | null = null;\n  let startPromise: Promise<Pid>;\n\n  const doStart = async () => {\n    const envStr = _.map(\n      cfg.extraEnv,\n      (value, name) => `${name}=${value} `\n    ).join('');\n    const commandStr = `${envStr}${cfg.command} ${cfg.args.join(' ')}`;\n    logger.info(`Service.start: trying to start ${commandStr}`, cfg);\n\n    const stdio = [\n      cfg.supportsCleanShutdown ? 'pipe' : 'ignore',\n      'inherit',\n      'inherit',\n    ];\n    const cwd = cfg.cwd ? { cwd: cfg.cwd } : {};\n    const env = cfg.extraEnv\n      ? { env: Object.assign({}, process.env, cfg.extraEnv) }\n      : {};\n    const options = Object.assign({ stdio }, cwd, env);\n    try {\n      proc = spawn(cfg.command, cfg.args, options);\n    } catch (err) {\n      logger.error(`Service.start: child_process.spawn() failed: ${err}`);\n      logger.error(\n        `Service.start: child_process.spawn(${cfg.command}, ${cfg.args.join(\n          ' '\n        )}, ...)`,\n        options\n      );\n      throw err;\n    }\n    setStatus(ServiceStatus.Started);\n    proc.on('exit', (code, signal) => {\n      onStopped(code, signal);\n    });\n    proc.on('error', err => {\n      logger.error(`Service.start: child_process failed: ${err}`);\n      onStopped(null, null, err);\n    });\n    return proc.pid;\n  };\n\n  const doStop = (timeoutSeconds: number) => {\n    logger.info(`Service.stop: trying to stop ${cfg.command}`, cfg);\n    setStatus(ServiceStatus.Stopping);\n    if (proc) {\n      if (cfg.supportsCleanShutdown && proc.stdin) {\n        proc.stdin.end();\n      } else {\n        proc.kill('SIGTERM');\n      }\n    }\n    killTimer = setTimeout(() => {\n      if (proc) {\n        logger.info(\n          `Service.stop: timed out after ${timeoutSeconds} seconds. Killing process ${proc.pid}.`\n        );\n        proc.kill('SIGKILL');\n      }\n    }, timeoutSeconds * 1000);\n  };\n\n  const onStopped = (\n    code: number | null = null,\n    signal: string | null = null,\n    err: Error | null = null\n  ) => {\n    exitStatus = { exe: cfg.command, code, signal, err };\n    logger.debug(`Service onStopped`, exitStatus);\n    if (killTimer) {\n      clearTimeout(killTimer);\n      killTimer = null;\n    }\n    proc = null;\n    setStatus(ServiceStatus.Stopped);\n  };\n\n  const waitForStop = (): Promise<ServiceExitStatus> =>\n    new Promise(resolve => {\n      logger.debug(`Service.stop: waiting for ServiceStatus.Stopped`);\n      events.on('statusChanged', status => {\n        if (status === ServiceStatus.Stopped && exitStatus) {\n          resolve(exitStatus);\n        }\n      });\n    });\n\n  const waitForExit = (): Promise<ServiceExitStatus> => {\n    const defaultExitStatus = {\n      exe: cfg ? cfg.command : '',\n      code: null,\n      signal: null,\n      err: null,\n    };\n    switch (status) {\n      case ServiceStatus.NotStarted:\n      case ServiceStatus.Starting:\n        return new Promise(resolve => {\n          status = ServiceStatus.Stopped;\n          exitStatus = defaultExitStatus;\n          resolve(exitStatus);\n        });\n      case ServiceStatus.Started:\n        return waitForStop();\n      case ServiceStatus.Stopping:\n        return waitForStop();\n      case ServiceStatus.Stopped:\n        return new Promise(resolve => resolve(exitStatus || defaultExitStatus));\n    }\n  };\n\n  const setStatus = (newStatus: ServiceStatus): void => {\n    logger.debug(\n      `setStatus ${ServiceStatus[status]} -> ${ServiceStatus[newStatus]}`\n    );\n    status = newStatus;\n    events.emit('statusChanged', status);\n  };\n\n  return {\n    start: async () => {\n      switch (status) {\n        case ServiceStatus.NotStarted:\n          setStatus(ServiceStatus.Starting);\n          startPromise = cfgPromise.then(theCfg => {\n            cfg = theCfg;\n            return doStart();\n          });\n          return startPromise;\n        case ServiceStatus.Starting:\n          logger.info(`Service.start: already starting`);\n          return startPromise;\n        case ServiceStatus.Started:\n          logger.info(`Service.start: already started`);\n          return proc ? proc.pid : -1;\n        case ServiceStatus.Stopping:\n          logger.info(`Service.start: cannot start - already stopping`);\n          return -1;\n        case ServiceStatus.Stopped:\n          logger.info(`Service.start: cannot start - already stopped`);\n          return -1;\n      }\n    },\n    stop: async (timeoutSeconds: number = 60): Promise<ServiceExitStatus> => {\n      switch (status) {\n        case ServiceStatus.NotStarted:\n          logger.info(`Service.stop: cannot stop - never started`);\n          break;\n        case ServiceStatus.Starting:\n        case ServiceStatus.Started:\n          doStop(timeoutSeconds);\n          break;\n        case ServiceStatus.Stopping:\n          if (timeoutSeconds === 0 && proc) {\n            logger.info(\n              `Service.stop: was already stopping, but will now kill process ${proc.pid} immediately`\n            );\n            proc.kill('SIGKILL');\n          } else {\n            logger.info(`Service.stop: already stopping`);\n          }\n          break;\n        case ServiceStatus.Stopped:\n          logger.info(`Service.stop: already stopped`);\n          break;\n      }\n      return waitForExit();\n    },\n    waitForExit,\n    getStatus: () => status,\n    events,\n  };\n}\n\n/**\n * Describes the command to run for the service.\n */\nexport interface StartService {\n  /** Program name. Will be searched for in `PATH`. */\n  command: string;\n  /** Command-line arguments. */\n  args: string[];\n  /** Directory to start program in. Helpful if it outputs files. */\n  cwd?: string;\n  /** Additional environment variables to set, on top of the current process environment. */\n  extraEnv?: { [propName: string]: string };\n  /**\n   * Whether this service supports the clean shutdown method documented in\n   * `docs/windows-clean-shutdown.md`.\n   */\n  supportsCleanShutdown: boolean;\n}\n","/**\n * Cheap and cheerful logging functions.\n * Same as what is already in Daedalus.\n * Plug in your own logging by implementing [[Logger]].\n *\n * @packageDocumentation\n /*\n\n/**\n * Logging adapter.\n */\nexport interface Logger {\n  debug: LogFunc;\n  info: LogFunc;\n  error: LogFunc;\n}\n\n/**\n * Function which logs a message and optional object.\n */\nexport interface LogFunc {\n  (msg: string, param?: any): void;\n}\n\n/**\n * Create a new logger with a context name added.\n *\n * @param logger - existing logger.\n * @param name - context to prepend.\n * @return - a new logger.\n */\nexport function prependName(logger: Logger, name: string): Logger {\n  const prefix = (\n    severity: 'debug' | 'info' | 'error',\n    msg: string,\n    param?: any\n  ) => {\n    const prefixed = `${name}: ${msg}`;\n    if (param) {\n      logger[severity](prefixed, param);\n    } else {\n      logger[severity](prefixed);\n    }\n  };\n  return {\n    debug: (msg: string, param?: any) => prefix('debug', msg, param),\n    info: (msg: string, param?: any) => prefix('info', msg, param),\n    error: (msg: string, param?: any) => prefix('error', msg, param),\n  };\n}\n","/**\n * Configuration for `cardano-node` (Byron)\n *\n * @packageDocumentation\n */\n\nimport path from 'path';\nimport getPort from 'get-port';\n\nimport { StartService } from './service';\nimport { FilePath, DirPath } from './common';\n\n/** Predefined networks. */\nexport const networks: { [propName: string]: ByronNetwork } = {\n  mainnet: {\n    configFile: 'configuration-mainnet.yaml',\n    genesisFile: 'mainnet-genesis.json',\n    genesisHash:\n      '5f20df933584822601f9e3f8c024eb5eb252fe8cefb24d1317dc3d432e940ebb',\n    topologyFile: 'mainnet-topology.json',\n  },\n};\n\n/**\n * Definition of a `cardano-node` (Byron) network.\n */\nexport interface ByronNetwork {\n  configFile: FilePath;\n  genesisFile: FilePath;\n  genesisHash: string;\n  topologyFile: FilePath;\n}\n\n/**\n * Configuration parameters for starting the rewritten version of\n * cardano-node (Byron).\n */\nexport interface ByronNodeConfig {\n  kind: 'byron';\n\n  /** Directory containing configurations for all networks. */\n  configurationDir: DirPath;\n\n  /** Network parameters */\n  network: ByronNetwork;\n\n  /**\n   * Directory which will contain a socket file to use for\n   * communicating with the node. Optional -- will be set\n   * automatically if not provided.\n   */\n  socketDir?: DirPath;\n}\n\n/**\n * The command-line arguments which can be supplied to `cardano-node` (Byron).\n */\nexport interface ByronNodeArgs {\n  /**\n   * Directory which will contain a socket file to use for\n   * communicating with the node.\n   */\n  socketDir: DirPath;\n\n  /**\n   * The path to a file describing the topology.\n   * Topology is ...\n   */\n  topologyFile: FilePath;\n\n  /** Directory where the state is stored. */\n  databaseDir: DirPath;\n\n  /** Path to the delegation certificate. */\n  delegationCertificate?: string;\n\n  /** Path to the signing key. */\n  signingKey?: string;\n\n  /** The genesis block for this network's chain. */\n  genesis: {\n    /** The filename of the genesis block. */\n    file: FilePath;\n    /** The hash of the genesis block. */\n    hash: string;\n  };\n\n  /** Configures the address to bind for P2P communication. */\n  listen: {\n    /** The TCP port for node P2P. */\n    port: number;\n    /** Optionally limit node P2P to one ipv6 or ipv4 address. */\n    address?: string;\n  };\n\n  /** Configuration file for the cardano-node. */\n  configFile: FilePath;\n\n  /** Validate all on-disk database files. */\n  validateDb?: boolean;\n\n  /**\n   * Extra arguments to add to the `cardano-node` command line.\n   */\n  extra?: string[];\n}\n\n/**\n * Convert a [[ByronNodeConfig]] into command-line arguments\n * ([[ByronNodeArgs]]) for `cardano-node`.\n */\nfunction makeArgs(\n  stateDir: DirPath,\n  config: ByronNodeConfig,\n  listenPort: number\n): ByronNodeArgs {\n  if (!config.socketDir) {\n    config.socketDir = 'sockets'; // relative to working directory\n  }\n  return {\n    socketDir: config.socketDir,\n    topologyFile: path.join(\n      config.configurationDir,\n      config.network.topologyFile\n    ),\n    databaseDir: 'chain', // relative to working directory\n    genesis: {\n      file: path.join(config.configurationDir, config.network.genesisFile),\n      hash: config.network.genesisHash,\n    },\n    listen: {\n      port: listenPort,\n    },\n    configFile: path.join(config.configurationDir, config.network.configFile),\n  };\n}\n\n/**\n * Chooses the command-line arguments for the node.\n *\n * @param stateDir - directory for node storage, specific to the node type and network.\n * @param config - parameters for starting the node.\n * @return the command-line for starting this node.\n */\nexport async function startByronNode(\n  stateDir: DirPath,\n  config: ByronNodeConfig\n): Promise<StartService> {\n  const listenPort = await getPort();\n  const args = makeArgs(stateDir, config, listenPort);\n  return {\n    command: 'cardano-node',\n    args: [\n      '--socket-dir',\n      args.socketDir,\n      '--topology',\n      args.topologyFile,\n      '--database-path',\n      args.databaseDir,\n      '--genesis-file',\n      args.genesis.file,\n      '--genesis-hash',\n      args.genesis.hash,\n      '--port',\n      '' + args.listen.port,\n      '--config',\n      args.configFile,\n    ]\n      .concat(args.listen.address ? ['--host-addr', args.listen.address] : [])\n      .concat(args.validateDb || false ? ['--validate-db'] : [])\n      .concat(args.signingKey ? ['--signing-key', args.signingKey] : [])\n      .concat(\n        args.delegationCertificate\n          ? ['--delegation-certificate', args.delegationCertificate]\n          : []\n      )\n      .concat(args.extra || []),\n    supportsCleanShutdown: false,\n    // set working directory to stateDir -- config file may have relative paths for logs.\n    cwd: stateDir,\n  };\n}\n","/**\n * Configuration for Jörmungandr.\n *\n * @packageDocumentation\n */\n\nimport path from 'path';\nimport _ from 'lodash';\nimport getPort from 'get-port';\nimport { StartService } from './service';\nimport { FilePath, DirPath } from './common';\n\n/**\n * Pre-defined networks for `jormungandr`. The \"self\" config is a\n * special one to create a local node.\n *\n * The config files are cached in the `test/data/jormungandr` directory of this repo.\n *\n * Download the latest configs from\n *   https://hydra.iohk.io/job/Cardano/iohk-nix/jormungandr-deployment/latest/download/1/index.html\n *\n */\nexport const networks: { [propName: string]: JormungandrNetwork } = {\n  itn_rewards_v1: {\n    configFile: 'itn_rewards_v1-config.yaml',\n    genesisBlock: {\n      hash: '8e4d2a343f3dcf9330ad9035b3e8d168e6728904262f2c434a4f8f934ec7b676',\n    },\n  },\n  self: {\n    configFile: 'config.yaml',\n    genesisBlock: {\n      file: 'block0.bin',\n      hash: 'f8c0622ea4b768421fea136a6e5a4e3b4c328fc5f16fad75817e40c8a2a56a56',\n    },\n    secretFile: ['secret.yaml'],\n  },\n};\n\n/**\n * Definition of a Jörmungandr network.\n */\nexport interface JormungandrNetwork {\n  configFile: FilePath;\n  genesisBlock: GenesisBlockHash | GenesisBlockFile;\n  secretFile?: FilePath[];\n}\n\n/**\n * Configuration parameters for starting the node.\n */\nexport interface JormungandrConfig {\n  kind: 'jormungandr';\n\n  /** Directory containing configurations for all networks. */\n  configurationDir: DirPath;\n\n  /** Network parameters */\n  network: JormungandrNetwork;\n\n  /** Optionally select a port for the node REST API. Otherwise, any unused port is chosen. */\n  restPort?: number;\n\n  /**\n   * Extra arguments to add to the `jormungandr` command line.\n   */\n  extraArgs?: string[];\n}\n\nexport interface GenesisBlockHash {\n  hash: string;\n}\n\nexport interface GenesisBlockFile extends GenesisBlockHash {\n  file: string;\n}\n\n/**\n * Models the command-line arguments which can be supplied to `jormungandr`.\n */\nexport interface JormungandrArgs {\n  /** Configuration file for the cardano-node. */\n  configFile: FilePath;\n\n  /** Directory where the state is stored. */\n  storageDir: DirPath;\n\n  genesisBlock: {\n    /** The file of the genesis block for this network's chain. */\n    file?: FilePath;\n    /** The hash of the genesis block for this network's chain. */\n    hash?: string;\n  };\n\n  /** BFT leaders secrets file(s). */\n  secretFile?: FilePath[];\n\n  /** Configures the address to bind for the REST API. */\n  restListen?: string;\n\n  /**\n   * Extra arguments to add to the `jormungandr` command line.\n   */\n  extra?: string[];\n}\nexport async function startJormungandr(\n  stateDir: DirPath,\n  config: JormungandrConfig\n): Promise<StartService> {\n  if (!config.restPort) {\n    config.restPort = await getPort();\n  }\n  const args = makeArgs(stateDir, config);\n  return {\n    command: 'jormungandr',\n    args: [\n      '--config',\n      args.configFile,\n      '--storage',\n      args.storageDir,\n      // note: To support log file rotation from jormungandr, capture\n      // its logs in json format and echo them into your frontend\n      // logging framework (which presumably supports log rotation).\n      // This will also mean that the node logs are correctly\n      // interleaved with the frontend logs.\n      // \"--log-format\", \"json\",\n    ]\n      .concat(args.restListen ? ['--rest-listen', args.restListen] : [])\n      .concat(\n        args.genesisBlock.file\n          ? ['--genesis-block', args.genesisBlock.file]\n          : args.genesisBlock.hash\n          ? ['--genesis-block-hash', args.genesisBlock.hash]\n          : []\n      )\n      .concat(_.flatMap(args.secretFile || [], secret => ['--secret', secret]))\n      .concat(args.extra || []),\n    supportsCleanShutdown: false,\n  };\n}\n\nfunction makeArgs(\n  stateDir: DirPath,\n  config: JormungandrConfig\n): JormungandrArgs {\n  return {\n    configFile: path.join(config.configurationDir, config.network.configFile),\n    restListen: `127.0.0.1:${config.restPort || 0}`,\n    genesisBlock: {\n      file:\n        'file' in config.network.genesisBlock\n          ? path.join(config.configurationDir, config.network.genesisBlock.file)\n          : undefined,\n      hash:\n        'hash' in config.network.genesisBlock\n          ? config.network.genesisBlock.hash\n          : undefined,\n    },\n    storageDir: path.join(stateDir, 'chain'),\n    secretFile: _.map(config.network.secretFile || [], secret =>\n      path.join(config.configurationDir, secret)\n    ),\n    extra: config.extraArgs,\n  };\n}\n","/**\n * Module for starting and managing a Cardano node and wallet backend.\n *\n * The main class is [[Launcher]].\n *\n * @packageDocumentation\n */\n\nimport path from 'path';\nimport mkdirp from 'mkdirp';\nimport process from 'process';\nimport net from 'net';\n\nimport _ from 'lodash';\nimport { EventEmitter } from 'tsee';\nimport getPort from 'get-port';\n\nimport { Logger, prependName } from './logging';\nimport {\n  Service,\n  ServiceExitStatus,\n  ServiceStatus,\n  StartService,\n  setupService,\n  serviceExitStatusMessage,\n} from './service';\nimport { DirPath } from './common';\n\nimport * as byron from './byron';\nimport * as shelley from './shelley';\nimport * as jormungandr from './jormungandr';\n\nexport {\n  ServiceStatus,\n  ServiceExitStatus,\n  serviceExitStatusMessage,\n  Service,\n} from './service';\n\n/**\n * Configuration parameters for starting the wallet backend and node.\n */\nexport interface LaunchConfig {\n  /**\n   * Directory to store wallet databases, the blockchain, socket\n   * files, etc.\n   */\n  stateDir: string;\n\n  /**\n   * Label for the network that will connected. This is used in the\n   * state directory path name.\n   */\n  networkName: string;\n\n  /**\n   * TCP port to use for the `cardano-wallet` API server.\n   * The default is to select any free port.\n   */\n  apiPort?: number;\n\n  /**\n   * IP address or hostname to bind the `cardano-wallet` API server\n   * to. Can be an IPv[46] address, hostname, or `'*'`. Defaults to\n   * 127.0.0.1.\n   */\n  listenAddress?: string;\n\n  /**\n   * Overrides the URL to the zip file containing stake pool metadata\n   * which is downloaded by cardano-wallet.\n   *\n   * This is only useful in testing scenarios, or when running a local\n   * development testnet.\n   *\n   * For Jörmungandr ITN, the default is\n   * https://github.com/cardano-foundation/incentivized-testnet-stakepool-registry/archive/master.zip.\n   */\n  stakePoolRegistryUrl?: string;\n\n  /**\n   * Maximum time difference (in seconds) between the tip slot and the\n   * latest applied block within which we consider a wallet being\n   * synced with the network. Defaults to 300 seconds.\n   */\n  syncToleranceSeconds?: number;\n\n  /**\n   * Configuration for starting `cardano-node`. The `kind` property will be one of\n   *  * `\"byron\"` - [[ByronNodeConfig]]\n   *  * `\"shelley\"` - [[ShelleyNodeConfig]]\n   *  * `\"jormungandr\"` - [[JormungandrConfig]]\n   */\n  nodeConfig:\n    | byron.ByronNodeConfig\n    | shelley.ShelleyNodeConfig\n    | jormungandr.JormungandrConfig;\n}\n\n/**\n * This is the main object which controls the launched wallet backend\n * and its node.\n *\n * Example:\n *\n * ```javascript\n * var launcher = new cardanoLauncher.Launcher({\n *   networkName: \"mainnet\",\n *   stateDir: \"/tmp/state-launcher\",\n *   nodeConfig: {\n *     kind: \"byron\",\n *     configurationDir: \"/home/user/cardano-node/configuration\",\n *     network: {\n *       configFile: \"configuration-mainnet.yaml\",\n *       genesisFile: \"mainnet-genesis.json\",\n *       genesisHash: \"5f20df933584822601f9e3f8c024eb5eb252fe8cefb24d1317dc3d432e940ebb\",\n *       topologyFile: \"mainnet-topology.json\"\n *     }\n *   }\n * });\n * ```\n *\n * Initially, the backend is not started. Use [[Launcher.start]] for that.\n */\nexport class Launcher {\n  /**\n   * Use this attribute to monitor and control the `cardano-wallet` process.\n   */\n  readonly walletService: Service;\n\n  /**\n   * Use this to access the `cardano-wallet` API server.\n   */\n  readonly walletBackend: WalletBackend;\n\n  /**\n   * Use this to monitor the `cardano-node` process.\n   */\n  readonly nodeService: Service;\n\n  /** Logging adapter */\n  protected logger: Logger;\n\n  /** Wallet API server port - set once it's known. */\n  private apiPort = 0;\n\n  /**\n   * Sets up a Launcher which can start and control the wallet backend.\n   *\n   * @param config - controls how the wallet and node are started\n   * @param logger - logging backend that launcher will use\n   */\n  constructor(config: LaunchConfig, logger: Logger = console) {\n    logger.debug('Launcher init');\n    this.logger = logger;\n\n    const start = makeServiceCommands(config, logger);\n    this.walletService = setupService(\n      start.wallet,\n      prependName(logger, 'wallet')\n    );\n    this.nodeService = setupService(start.node, prependName(logger, 'node'));\n\n    this.walletBackend = {\n      getApi: () => new V2Api(this.apiPort),\n      events: new EventEmitter<{\n        ready: (api: Api) => void;\n        exit: (status: ExitStatus) => void;\n      }>(),\n    };\n\n    start.wallet.then((startService: WalletStartService) => {\n      this.apiPort = startService.apiPort;\n    });\n\n    this.walletService.events.on('statusChanged', status => {\n      if (status === ServiceStatus.Stopped) {\n        this.logger.debug('wallet exited');\n        this.stop();\n      }\n    });\n\n    this.nodeService.events.on('statusChanged', status => {\n      if (status === ServiceStatus.Stopped) {\n        this.logger.debug('node exited');\n        this.stop();\n      }\n    });\n\n    this.installSignalHandlers();\n  }\n\n  /**\n   * Starts the wallet and node.\n   *\n   * Example:\n   *\n   * ```javascript\n   * launcher.start().then(function(api) {\n   *   console.log(\"*** cardano-wallet backend is ready, base URL is \" + api.baseUrl);\n   * });\n   * ```\n   *\n   * @return a promise that will be fulfilled when the wallet API\n   * server is ready to accept requests.\n   */\n  start(): Promise<Api> {\n    this.nodeService.start();\n    this.walletService.start();\n\n    this.waitForApi().then(() => {\n      this.walletBackend.events.emit('ready', this.walletBackend.getApi());\n    });\n\n    return new Promise((resolve, reject) => {\n      this.walletBackend.events.on('ready', resolve);\n      this.walletBackend.events.on('exit', reject);\n    });\n  }\n\n  /**\n   * Poll TCP port of wallet API server until it accepts connections.\n   * @param port - TCP port number\n   * @return a promise that is completed once the wallet API server accepts connections.\n   */\n  private waitForApi(): Promise<void> {\n    this.logger.debug('waitForApi');\n    return new Promise(resolve => {\n      let addr: net.SocketConnectOpts;\n      var client: net.Socket;\n      const poll = () => {\n        if (this.apiPort) {\n          if (!addr) {\n            addr = { port: this.apiPort, host: '127.0.0.1' };\n            this.logger.info(\n              `Waiting for tcp port ${addr.host}:${addr.port} to accept connections...`\n            );\n          }\n\n          if (client) {\n            client.destroy();\n          }\n          client = new net.Socket();\n          client.connect(addr, () => {\n            this.logger.info(`... port is ready.`);\n            clearInterval(timer);\n            resolve();\n          });\n          client.on('error', err => {\n            this.logger.debug(`waitForApi: not ready yet: ${err}`);\n          });\n        }\n      };\n      const timer = setInterval(poll, 250);\n    });\n  }\n\n  /**\n   * Stops the wallet backend. Attempts to cleanly shut down the\n   * processes. However, if they have not exited before the timeout,\n   * they will be killed.\n   *\n   * @param timeoutSeconds - how long to wait before killing the processes.\n   * @return a [[Promise]] that is fulfilled at the timeout, or before.\n   *\n   * @event exit - `walletBackend.events` will emit this when the\n   *   wallet and node have both exited.\n   */\n  stop(\n    timeoutSeconds = 60\n  ): Promise<{ wallet: ServiceExitStatus; node: ServiceExitStatus }> {\n    this.logger.debug(`Launcher.stop: stopping wallet and node`);\n    return Promise.all([\n      this.walletService.stop(timeoutSeconds),\n      this.nodeService.stop(timeoutSeconds),\n    ]).then(([wallet, node]) => {\n      const status = { wallet, node };\n      this.logger.debug(`Launcher.stop: both services are stopped.`, status);\n      this.walletBackend.events.emit('exit', status);\n      return status;\n    });\n  }\n\n  /**\n   * Stop services when this process gets killed.\n   */\n  private installSignalHandlers(): void {\n    const cleanup = (signal: string) => {\n      this.logger.info(`Received ${signal} - stopping services...`);\n      this.walletService.stop(0);\n      this.nodeService.stop(0);\n    };\n    ['SIGINT', 'SIGTERM', 'SIGHUP', 'SIGBREAK'].forEach((signal: string) =>\n      process.on(signal as any, cleanup)\n    );\n  }\n}\n\ninterface RequestParams {\n  port: number;\n  path: string;\n  hostname: string;\n}\n\n/**\n * Connection parameters for the `cardano-wallet` API.\n * These should be used to build the HTTP requests.\n */\nexport interface Api {\n  /**\n   * API base URL, including trailling slash.\n   */\n  baseUrl: string;\n\n  /**\n   * URL components which can be used with the HTTP client library of\n   * your choice.\n   */\n  requestParams: RequestParams;\n}\n\nclass V2Api implements Api {\n  /** URL of the API, including a trailling slash. */\n  readonly baseUrl: string;\n  /** URL components which can be used with the HTTP client library of\n   * your choice. */\n  readonly requestParams: RequestParams;\n\n  constructor(port: number) {\n    let hostname = '127.0.0.1';\n    let path = '/v2/';\n    this.baseUrl = `http://${hostname}:${port}${path}`;\n    this.requestParams = { port, path, hostname };\n  }\n}\n\n/**\n * The result after the launched wallet backend has finished.\n */\nexport interface ExitStatus {\n  wallet: ServiceExitStatus;\n  node: ServiceExitStatus;\n}\n\n/**\n * Format an [[ExitStatus]] as a multiline human-readable string.\n */\nexport function exitStatusMessage(status: ExitStatus): string {\n  return _.map(status, serviceExitStatusMessage).join('\\n');\n}\n\n/**\n * Represents the API service of `cardano-wallet`.\n */\nexport interface WalletBackend {\n  /**\n   * @return HTTP connection parameters for the `cardano-wallet` API server.\n   */\n  getApi(): Api;\n\n  /**\n   * An [[EventEmitter]] that can be used to register handlers when\n   * the process changes status.\n   *\n   * ```typescript\n   * launcher.walletBackend.events.on('ready', api => { ... });\n   * ```\n   */\n  events: WalletBackendEvents;\n}\n\n/**\n * The type of events for [[WalletBackend]].\n */\ntype WalletBackendEvents = EventEmitter<{\n  /**\n   * [[Launcher.walletBackend.events]] will emit this when the API\n   *  server is ready to accept requests.\n   * @event\n   */\n  ready: (api: Api) => void;\n  /** [[Launcher.walletBackend.events]] will emit this when the\n   *  wallet and node have both exited.\n   * @event\n   */\n  exit: (status: ExitStatus) => void;\n}>;\n\ninterface WalletStartService extends StartService {\n  apiPort: number;\n}\n\nfunction makeServiceCommands(\n  config: LaunchConfig,\n  logger: Logger\n): { wallet: Promise<WalletStartService>; node: Promise<StartService> } {\n  const baseDir = path.join(\n    config.stateDir,\n    config.nodeConfig.kind,\n    config.networkName\n  );\n  logger.info(\n    `Creating base directory ${baseDir} (if it doesn't already exist)`\n  );\n  const node = mkdirp(baseDir).then(() => nodeExe(baseDir, config));\n  const wallet = node.then(nodeService =>\n    walletExe(baseDir, config, nodeService)\n  );\n  return { wallet, node };\n}\n\nasync function walletExe(\n  baseDir: DirPath,\n  config: LaunchConfig,\n  node: StartService\n): Promise<WalletStartService> {\n  const apiPort = config.apiPort || (await getPort());\n  const base: WalletStartService = {\n    command: `cardano-wallet-${config.nodeConfig.kind}`,\n    args: [\n      'serve',\n      '--shutdown-handler',\n      '--port',\n      '' + apiPort,\n      '--database',\n      path.join(baseDir, 'wallet'),\n    ].concat(\n      config.listenAddress ? ['--listen-address', config.listenAddress] : [],\n      config.syncToleranceSeconds\n        ? ['--sync-tolerance', `${config.syncToleranceSeconds}s`]\n        : []\n    ),\n    extraEnv: config.stakePoolRegistryUrl\n      ? { CARDANO_WALLET_STAKE_POOL_REGISTRY_URL: config.stakePoolRegistryUrl }\n      : undefined,\n    supportsCleanShutdown: true,\n    apiPort,\n  };\n  const addArgs = (args: string[]): WalletStartService =>\n    _.assign(base, { args: base.args.concat(args) });\n\n  switch (config.nodeConfig.kind) {\n    case 'jormungandr':\n      return addArgs([\n        '--genesis-block-hash',\n        config.nodeConfig.network.genesisBlock.hash,\n        '--node-port',\n        '' + config.nodeConfig.restPort,\n      ]);\n    case 'byron':\n      return addArgs(\n        config.nodeConfig.socketDir\n          ? ['--node-socket', config.nodeConfig.socketDir]\n          : []\n      );\n    case 'shelley':\n      return base;\n  }\n}\n\nfunction nodeExe(\n  baseDir: DirPath,\n  config: LaunchConfig\n): Promise<StartService> {\n  switch (config.nodeConfig.kind) {\n    case 'jormungandr':\n      return jormungandr.startJormungandr(baseDir, config.nodeConfig);\n    case 'byron':\n      return byron.startByronNode(baseDir, config.nodeConfig);\n    case 'shelley':\n      return shelley.startShelleyNode(config.nodeConfig);\n  }\n}\n","/**\n * Configuration for `cardano-node` (Shelley).\n *\n * @packageDocumentation\n */\n\nimport { StartService } from './service';\n\n/**\n * Configuration parameters for starting cardano-node (Shelley).\n *\n * Unimplemented!\n */\nexport interface ShelleyNodeConfig {\n  kind: 'shelley';\n\n  /**\n   * Directory which will contain a socket file to use for communicating with the node.\n   * Defaults to a subdirectory of the state directory.\n   */\n  socketDir?: string;\n\n  /**\n   * Contents of the `cardano-node` config file.\n   */\n  extraConfig?: { [propName: string]: any };\n\n  /**\n   * Extra arguments to add to the `cardano-node` command line.\n   */\n  extraArgs?: string[];\n}\n\nexport async function startShelleyNode(\n  config: ShelleyNodeConfig\n): Promise<StartService> {\n  throw new Error('shelley backend not implemented');\n  // return {\n  //   command: \"cardano-node\", args: [\"--help\"]\n  // };\n}\n","/**\n * `cardano-launcher` command-line interface.\n *\n * This tool can be used for testing.\n *\n * See also: the entrypoint script `bin/cardano-launcher`.\n *\n * @packageDocumentation\n */\n\nimport process from 'process';\nimport _ from 'lodash';\n\nimport {\n  Launcher,\n  ExitStatus,\n  ServiceExitStatus,\n  serviceExitStatusMessage,\n} from './cardanoLauncher';\n\nimport * as byron from './byron';\nimport * as jormungandr from './jormungandr';\n\nfunction combineStatus(statuses: ServiceExitStatus[]): number {\n  let code = _.reduce(\n    statuses,\n    (res: number | null, status) => (res === null ? status.code : res),\n    null\n  );\n  let signal = _.reduce(\n    statuses,\n    (res: string | null, status) => (res === null ? status.signal : res),\n    null\n  );\n  // let err = _.reduce(statuses, (res, status) => res === null ? status.err : res, null);\n\n  return code === null ? (signal === null ? 0 : 127) : code;\n}\n\n/**\n * Main function of the CLI.\n *\n * Is just a very basic interface for testing things.\n */\nexport function cli(args: string[]) {\n  const waitForExit = setInterval(function() {}, 3600000);\n\n  args.shift(); // /usr/bin/node\n  args.shift(); // cardano-launcher\n\n  if (args.length < 4) {\n    usage();\n  }\n\n  const backend = args.shift() as string;\n  const networkName = args.shift() as string;\n  const configurationDir = args.shift() as string;\n  const stateDir = args.shift() as string;\n\n  let nodeConfig: any;\n\n  if (backend === 'byron') {\n    if (!(networkName in byron.networks)) {\n      console.error(`unknown network: ${networkName}`);\n      process.exit(2);\n    }\n    const network = byron.networks[networkName];\n    nodeConfig = {\n      kind: backend,\n      configurationDir,\n      network,\n    };\n  } else if (backend === 'jormungandr') {\n    if (!(networkName in jormungandr.networks)) {\n      console.error(`unknown network: ${networkName}`);\n      process.exit(2);\n    }\n    const network = jormungandr.networks[networkName];\n    nodeConfig = {\n      kind: backend,\n      configurationDir,\n      network,\n    };\n  } else {\n    usage();\n  }\n\n  const launcher = new Launcher({ stateDir, nodeConfig, networkName }, console);\n\n  launcher.start();\n\n  // inform tests of subprocess pids\n  launcher.nodeService.start().then(pid => sendMaybe({ node: pid }));\n  launcher.walletService.start().then(pid => sendMaybe({ wallet: pid }));\n\n  launcher.walletBackend.events.on('exit', (status: ExitStatus) => {\n    console.log(serviceExitStatusMessage(status.wallet));\n    console.log(serviceExitStatusMessage(status.node));\n    clearInterval(waitForExit);\n    process.exit(combineStatus([status.wallet, status.node]));\n  });\n}\n\nfunction usage() {\n  console.log('usage: cardano-launcher BACKEND NETWORK CONFIG-DIR STATE-DIR');\n  console.log('  BACKEND    - either jormungandr or byron');\n  console.log(\n    '  NETWORK    - depends on backend, e.g. mainnet, itn_rewards_v1'\n  );\n  console.log(\n    '  CONFIG-DIR - directory which contains config files for a backend'\n  );\n  console.log('  STATE-DIR  - directory to put blockchains, databases, etc.');\n  process.exit(1);\n}\n\nfunction sendMaybe(message: object) {\n  if (process.send) {\n    process.send(message);\n  }\n}\n"],"names":["ServiceStatus","prependName","logger","name","prefix","severity","msg","param","prefixed","debug","info","error","serviceExitStatusMessage","res","exe","code","signal","err","setupService","cfgPromise","console","cfg","exitStatus","startPromise","events","EventEmitter","status","NotStarted","proc","killTimer","onStopped","command","clearTimeout","setStatus","Stopped","waitForExit","defaultExitStatus","Starting","Promise","resolve","Started","Stopping","on","newStatus","emit","start","then","theCfg","commandStr","_","map","extraEnv","value","join","args","stdio","supportsCleanShutdown","cwd","env","Object","assign","process","options","spawn","pid","doStart","stop","timeoutSeconds","stdin","end","kill","setTimeout","doStop","getStatus","networks","mainnet","configFile","genesisFile","genesisHash","topologyFile","itn_rewards_v1","genesisBlock","hash","self","file","secretFile","Launcher","config","baseDir","path","stateDir","nodeConfig","kind","networkName","node","mkdirp","configurationDir","network","restListen","restPort","undefined","storageDir","secret","extra","extraArgs","makeArgs","concat","flatMap","getPort","jormungandr","listenPort","socketDir","databaseDir","genesis","listen","port","address","validateDb","signingKey","delegationCertificate","byron","Error","shelley","nodeExe","wallet","nodeService","apiPort","base","listenAddress","syncToleranceSeconds","stakePoolRegistryUrl","CARDANO_WALLET_STAKE_POOL_REGISTRY_URL","addArgs","walletExe","makeServiceCommands","walletService","walletBackend","getApi","V2Api","_this","startService","installSignalHandlers","waitForApi","_this2","reject","addr","client","timer","setInterval","_this3","host","destroy","net","Socket","connect","clearInterval","all","this","_this4","cleanup","_this5","forEach","baseUrl","requestParams","hostname","usage","log","exit","sendMaybe","message","send","shift","length","backend","launcher","statuses","reduce"],"mappings":"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"}